

def maxProfit(prices):
    """
        最佳买卖股票时机含冷冻期
        给定一个整数数组, 其中第 i 个元素代表了第 i 天的股票价格
        设计一个算法计算出最大利润. 在满足以下约束条件下, 你可以尽可能地完成更多的交易(多次买卖一支股票):
        你不能同时参与多笔交易(你必须在再次购买前出售掉之前的股票)
        卖出股票后, 你无法在第二天买入股票(即冷冻期为 1 天)

        可以有以下四个状态
        状态一: 买入股票状态(今天买入股票, 或者是之前就买入了股票然后没有操作)
        卖出股票状态, 这里就有两种卖出股票状态:
            状态二: 两天前就卖出了股票, 度过了冷冻期, 一直没操作, 今天保持卖出股票状态
            状态三: 今天卖出了股票
        状态四: 今天为冷冻期状态, 但冷冻期状态不可持续, 只有一天!
    """
    n = len(prices)
    dp = [[0] * 4 for _ in range(n)]    # dp[i][j]定义: 第i天状态为j, 所剩的最多现金为dp[i][j]
    dp[0][0] = -prices[0]
    for i in range(1, n):
        # dp[i][0]操作一: 前一天就是持有股票状态(状态一)dp[i][0] = dp[i - 1][0]; 
        # 操作二: (1)前一天是冷冻期(状态四d)p[i - 1][3] - prices[i], (2)前一天是保持卖出股票状态(状态二)dp[i - 1][1] - prices[i]
        dp[i][0] = max(dp[i-1][0], max(dp[i-1][3], dp[i-1][1]) - prices[i])
        dp[i][1] = max(dp[i-1][1], dp[i-1][3])      # (1)前一天就是状态二; (2)前一天是冷冻期(状态四)
        dp[i][2] = dp[i-1][0] + prices[i]           # 昨天一定是买入股票状态(状态一)今天卖出
        dp[i][3] = dp[i-1][2]                       # 昨天卖出了股票(状态三)
    return max(dp[n-1][3], dp[n-1][1], dp[n-1][2])

aaa = maxProfit([1,2,3,0,2])
print(aaa)