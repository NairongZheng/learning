# tree树相关问题
看看这个[超神链接](https://www.bilibili.com/video/BV1nG411x77H)
0. acm模式构建二叉树
1. 二叉树的前序遍历
2. 二叉树的中序遍历
3. 二叉树的后序遍历
4. 二叉树的层序遍历
5. 翻转二叉树
6. 二叉树的最小深度
7. 平衡二叉树
8. 二叉树的所有路径
9. 二叉树路径总和
10. 二叉树路径总和II
11. 从中序与后序遍历序列构造二叉树
12. 合并二叉树
13. 二叉树公共祖先问题
14. 二叉搜索树中的插入操作
15. 删除二叉搜索树中的节点
16. 树的子结构
17. 二叉树的最大深度
18. 二叉树的直径
19. 填充每个节点的下一个右侧节点指针
20. 二叉树展开为链表
21. 根据前序和后序遍历构造二叉树
22. 二叉树的序列化与反序列化


#### 1. 二叉树
二叉树解题的思维模式分两类：
- **是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个**traverse**函数配合外部变量来实现，这叫「遍历」的思维模式。
- **是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，都需要思考：
**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。
#### 2. 深入理解前中后序遍历
**所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候**，那么进一步，你把代码写在不同位置，代码执行的时机也不同。下面这个代码不简单，好好悟。
```python
def traverse(root):
    if not root:
        return None
    # 前序位置
    traverse(root.left)
    # 中序位置
    traverse(root.right)
    # 后续位置
```
**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：
- 前序位置的代码在刚刚进入一个二叉树节点的时候执行；
- 后序位置的代码在将要离开一个二叉树节点的时候执行；(一般用到后序，都是分解问题的思路)
- 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。


两个简单问题：
1. 如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？
2. 如何打印出每个节点的左右子树各有多少节点？

那么可以这么写代码：
问题一（遍历的方法--前序）：
```python
# 二叉树遍历函数
def traverse(root, level):
    if not root:
        return
    # 前序位置
    print('节点{}在第{}层'.format(root, level))
    traverse(root.left, level + 1)
    traverse(root.right, level + 1)

traverse(root, 1)
```

问题二（分解问题的方法--后序）：
```python
def count(root):
    """
        定义：输入一棵二叉树，返回这棵二叉树的节点总数！！！
    """
    if not root:
        return 0
    left_count = count(root.left)
    right_count = count(root.right)
    # 后序位置
    print('节点{}的左子树有{}个节点，右子树有{}个节点'.format(root, left_count, right_count))
    return left_count + right_count + 1
```

- **意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。
- **那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**。

#### 3. 两种思路
- tree1、tree17、tree18、tree5、tree19、tree20