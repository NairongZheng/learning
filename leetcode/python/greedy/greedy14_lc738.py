

def monotoneIncreasingDigits(n):
    """
        单调递增的数字
        给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。

        思路：
        局部最优：遇到strNum[i - 1] > strNum[i]的情况，让strNum[i - 1]--，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数。
        全局最优：得到小于等于N的最大单调递增的整数。
        但这里局部最优推出全局最优，还需要其他条件，即遍历顺序，和标记从哪一位开始统一改成9。

        是从前向后遍历还是从后向前遍历呢？
        举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。
        所以从前后向遍历会改变已经遍历过的结果！
        那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -> 329 -> 299
    """
    a = list(str(n))
    for i in range(len(a) - 1, 0, -1):
        if int(a[i]) < int(a[i - 1]):
            a[i - 1] = str(int(a[i - 1]) - 1)
            a[i:] = '9' * (len(a) - i)
    return int(''.join(a))

aaa = monotoneIncreasingDigits(326)
print(aaa)      # 299