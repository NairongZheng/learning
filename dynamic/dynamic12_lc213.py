

def rob(nums):
    """
        打家劫舍II
        你是一个专业的小偷, 计划偷窃沿街的房屋, 每间房内都藏有一定的现金. 这个地方所有的房屋都围成一圈, 
        这意味着第一个房屋和最后一个房屋是紧挨着的. 同时, 相邻的房屋装有相互连通的防盗系统, 
        如果两间相邻的房屋在同一晚上被小偷闯入, 系统会自动报警
        给定一个代表每个房屋存放金额的非负整数数组, 计算你在不触动警报装置的情况下, 能够偷窃到的最高金额

        关键: 房屋围成一圈

        分析:
        对于一个数组, 成环要考虑三种情况: (1)考虑不包含首位元素; (2)考虑包含首元素, 不包含尾元素; (3)考虑包含尾元素, 不包含首元素
        情况一二三是"考虑"的范围, 而具体房间偷与不偷交给递推公式去抉择
        所以在本题中, 其实情况二三就包含情况一了
    """

    def roblist(nums):
        dp = [0 for _ in range(len(nums))]
        dp[0] = nums[0]
        for i in range(1, len(nums)):
            if i == 1:
                dp[i] = max(dp[i - 1], nums[i])
            else:
                dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
        return dp[-1]

    # 在198入门级的打家劫舍问题上分两种情况考虑
    # 一是不偷第一间房, 二是不偷最后一间房
    if len(nums) == 1:
        return nums[0]
    val1 = roblist(nums[1:])    # 不偷第一间房
    val2 = roblist(nums[:-1])   # 不偷最后一间房
    return max(val1, val2)

aaa = rob([2,3,2])
print(aaa)
